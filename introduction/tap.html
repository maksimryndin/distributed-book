<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Practice: virtual interface - Distributed systems for busy engineer</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded "><a href="../introduction/overview.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/network.html"><strong aria-hidden="true">1.1.</strong> Network stack</a></li><li class="chapter-item expanded "><a href="../introduction/tap.html" class="active"><strong aria-hidden="true">1.2.</strong> Practice: virtual interface</a></li><li class="chapter-item expanded "><a href="../introduction/network-properties.html"><strong aria-hidden="true">1.3.</strong> Unreliable network</a></li><li class="chapter-item expanded "><a href="../introduction/measure-network.html"><strong aria-hidden="true">1.4.</strong> Measuring network</a></li><li class="chapter-item expanded "><a href="../introduction/availability.html"><strong aria-hidden="true">1.5.</strong> Availability</a></li><li class="chapter-item expanded "><a href="../introduction/decentralized.html"><strong aria-hidden="true">1.6.</strong> Distributed vs Decentralized</a></li><li class="chapter-item expanded "><a href="../introduction/taste-distributed.html"><strong aria-hidden="true">1.7.</strong> Taste of distributed</a></li><li class="chapter-item expanded "><a href="../introduction/exercises.html"><strong aria-hidden="true">1.8.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../established-systems/overview.html"><strong aria-hidden="true">2.</strong> Established systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../established-systems/erlang.html"><strong aria-hidden="true">2.1.</strong> Erlang/OTP</a></li></ol></li><li class="chapter-item expanded "><a href="../consensus/overview.html"><strong aria-hidden="true">3.</strong> Consensus</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../consensus/raft.html"><strong aria-hidden="true">3.1.</strong> Raft</a></li><li class="chapter-item expanded "><a href="../consensus/transactions.html"><strong aria-hidden="true">3.2.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="../consensus/viewstamped.html"><strong aria-hidden="true">3.3.</strong> Viewstamped Replication</a></li></ol></li><li class="chapter-item expanded "><a href="../consistency/overview.html"><strong aria-hidden="true">4.</strong> Consistency</a></li><li class="chapter-item expanded "><a href="../computing/overview.html"><strong aria-hidden="true">5.</strong> Distributed computing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../computing/ml_training.html"><strong aria-hidden="true">5.1.</strong> ML training</a></li></ol></li><li class="chapter-item expanded "><a href="../decentralized/overview.html"><strong aria-hidden="true">6.</strong> Decentralized</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../decentralized/p2p.html"><strong aria-hidden="true">6.1.</strong> p2p networks</a></li><li class="chapter-item expanded "><a href="../decentralized/blockchain.html"><strong aria-hidden="true">6.2.</strong> Blockchain</a></li><li class="chapter-item expanded "><a href="../decentralized/smart-contracts.html"><strong aria-hidden="true">6.3.</strong> Smart contracts</a></li></ol></li><li class="chapter-item expanded "><a href="../references.html"><strong aria-hidden="true">7.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Distributed systems for busy engineer</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/maksimryndin/distributed-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="practice-virtual-interface"><a class="header" href="#practice-virtual-interface">Practice: virtual interface</a></h1>
<p>As we already discussed, at the link layer of TCP/IP we have network interfaces allowing us to interact with a network devices. But this network devices can be completely virtual allowing a userspace program interact with a network<sup class="footnote-reference"><a href="#userspace_tcpip">1</a></sup> at the link layer (TAP device) and the internet layer (TUN device) which is used in different tunneling programs like vpns. You can create such interfaces with console commands (like <code>ip tuntap</code>) but let’s try to create a TAP device programmaticaly. There <a href="https://www.kernel.org/doc/Documentation/networking/tuntap.txt">C examples</a> but let’s do it in Rust from scratch<sup class="footnote-reference"><a href="#tcpip_tutorial">2</a></sup>.</p>
<p>We create rust workspace (a collection of several packages) to have some experiments with the network in further chapters (you can find all the code in the <a href="https://github.com/maksimryndin/netstack">netstack repository</a>).</p>
<pre><code class="language-bash ignore">$ mkdir netstack
$ cd netstack
</code></pre>
<p>In the <code>netstack</code> directory we create <code>Cargo.toml</code> with the contents:</p>
<pre><code class="language-toml ignore">[workspace]

members = [
    "virtual-interface",
    "bindings",
]
</code></pre>
<p>After we create libs running <code>cargo new --lib virtual-interface</code> and <code>cargo new --lib bindings</code> in the <code>netstack</code> directory. So to create a virtual network device, we need to open for a read-write access file <code>/dev/net/tun</code> and configure it with <code>ioctl</code> - a swiss knife of device management in Unix/Linux. Essentialy, <code>ioctl</code> as a universal system call (please see <code>man ioctl</code>) was created to control different devices and be extensible to manage new types of devices. To achieve this goal <code>ioctl</code> accepts an open file descriptor (device), a request code - unsigned long number which is <a href="https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt">unique across devices</a> and it can accept a pointer to some datastructure related to the specific device. In our case of a network device (TAP device) such a control structure is <code>ifreq</code> (<em>interface request</em>, see <code>man 7 netdevice</code>) and a request code is <code>TUNSETIFF</code>.</p>
<p>Rust provides <a href="https://crates.io/crates/libc">libc</a> crate as raw ffi bindings for system libraries so we could use <a href="https://rust-lang.github.io/libc/aarch64-unknown-linux-gnu/doc/libc/fn.ioctl.html">ioctl</a> and some constants but it is missing constants for TUN and TAP devices. So anyway as we need to create some bindings ourselves let use <a href="https://crates.io/crates/bindgen">bindgen</a> crate to generate bindings for system libraries at the build time. Following <a href="https://rust-lang.github.io/rust-bindgen/tutorial-0.html">bidngen tutorial</a> we create a <code>netstack/bindings/wrapper.h</code> file where we place necessary headers:</p>
<pre><code class="language-c ignore">#include &lt;sys/ioctl.h&gt;
#include &lt;linux/if.h&gt;
#include &lt;linux/if_tun.h&gt;
</code></pre>
<p>and create <code>bindings/build.rs</code> with the contents</p>
<pre><code class="language-rust ignore">extern crate bindgen;

use std::env;
use std::path::PathBuf;

fn main() {
    // Tell cargo to invalidate the built crate whenever the wrapper changes
    println!("cargo:rerun-if-changed=wrapper.h");

    // The bindgen::Builder is the main entry point
    // to bindgen, and lets you build up options for
    // the resulting bindings.
    let bindings = bindgen::Builder::default()
        // The input header we would like to generate
        // bindings for.
        .header("wrapper.h")
        // Tell cargo to invalidate the built crate whenever any of the
        // included header files changed.
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        // Finish the builder and generate the bindings.
        .generate()
        // Unwrap the Result and panic on failure.
        .expect("Unable to generate bindings");

    // Write the bindings to the $OUT_DIR/bindings.rs file.
    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}</code></pre>
<p>Run <code>cargo build</code> and at <code>target/debug/build/bindings-.../out/bindings.rs</code> we can find needed bindings except <code>TUNSETIFF</code> which is a required request code for <code>ioctl</code> (bindgen <a href="https://github.com/rust-lang/rust-bindgen/issues/753">do not generate bindings for functional macros</a>) so if we check contents of <code>/usr/include/linux/if_tun.h</code> then we see <code>TUNSETIFF</code> is a functional macro <code>#define TUNSETIFF _IOW('T', 202, int)</code> so let’s port the C macro code from <code>/usr/include/asm-generic/ioctl.h</code> where participating macros live.</p>
<p>In <code>netstack/bindings/src/lib.rs</code></p>
<pre><code class="language-rust ignore">include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
use std::mem;
use std::os::raw;

// /usr/include/asm-generic/ioctl.h
const IOC_SIZEBITS: u8 = 14;
const IOC_NRBITS: u8 = 8;
const IOC_TYPEBITS: u8 = 8;
const IOC_NRSHIFT: u8 = 0;
const IOC_TYPESHIFT: u8 = IOC_NRSHIFT + IOC_NRBITS;
const IOC_SIZESHIFT: u8 = IOC_TYPESHIFT + IOC_TYPEBITS;
const IOC_DIRSHIFT: u8 = IOC_SIZESHIFT + IOC_SIZEBITS;
const IOC_WRITE: u32 = 1;

//#define TUNSETIFF     _IOW('T', 202, int)
const INT_SIZE: usize = mem::size_of::&lt;raw::c_int&gt;();
pub const TUNSETIFF: u32 = IOC_WRITE &lt;&lt; IOC_DIRSHIFT
    | (b'T' as u32) &lt;&lt; IOC_TYPESHIFT
    | 202 &lt;&lt; IOC_NRSHIFT
    | (INT_SIZE as u32) &lt;&lt; IOC_SIZESHIFT;</code></pre>
<p>Let’s add file <code>netstack/virtual-interface/src/tap.rs</code> where main things happen</p>
<pre><code class="language-rust ignore">use std::ffi;
use std::fs::{File, OpenOptions};
use std::io;
use std::mem;
use std::os::unix::io::{FromRawFd, IntoRawFd};

use bindings;

const VIRTUAL_DEVICE: &amp;str = "/dev/net/tun";

#[derive(Debug)]
pub enum VirtualInterfaceError {
    IoError(io::Error),
    IoctlError,
    DeviceNameTooLong,
    DeviceNameContainsNulByte(ffi::NulError),
}

impl From&lt;io::Error&gt; for VirtualInterfaceError {
    fn from(error: io::Error) -&gt; Self {
        VirtualInterfaceError::IoError(error)
    }
}

impl From&lt;ffi::NulError&gt; for VirtualInterfaceError {
    fn from(error: ffi::NulError) -&gt; Self {
        VirtualInterfaceError::DeviceNameContainsNulByte(error)
    }
}

pub struct VirtualInterface {
    device: File,
}

impl VirtualInterface {
    pub fn create(name: &amp;str) -&gt; Result&lt;Self, VirtualInterfaceError&gt; {
        // reserve 1 byte for '\0'
        if name.len() &gt;= bindings::IFNAMSIZ as usize {
            return Err(VirtualInterfaceError::DeviceNameTooLong);
        }
        // We have to check that the device name has no zero bytes in the middle
        let device_name = ffi::CString::new(name)?.into_bytes_with_nul();
        let device = OpenOptions::new()
            .read(true)
            .write(true)
            .open(VIRTUAL_DEVICE)?;
        // ifreq is a structure to control network device (see man 7 netdevice)
        let mut ifr: bindings::ifreq = unsafe { mem::zeroed() };

        // create stack allocated array to hold the device name
        let mut name_buffer = [0_u8; bindings::IFNAMSIZ as usize];
        // and copy name bytes to it
        for (i, b) in device_name.into_iter().enumerate() {
            name_buffer[i] = b;
        }
        ifr.ifr_ifrn.ifrn_name = name_buffer;
        // IFF_TAP - tap device
        // IFF_NO_PI - no additional info for Ethernet package
        // IFF_TUN_EXCL - prevent creation of duplicates
        ifr.ifr_ifru.ifru_flags = (bindings::IFF_TAP | bindings::IFF_NO_PI | bindings::IFF_TUN_EXCL)
            as std::os::raw::c_short;

        let raw_fd = device.into_raw_fd();
        if unsafe { bindings::ioctl(raw_fd, bindings::TUNSETIFF as u64, &amp;mut ifr as *mut _) } == -1
        {
            return Err(VirtualInterfaceError::IoctlError);
        }
        let device = unsafe { File::from_raw_fd(raw_fd) };
        Ok(Self { device })
    }

    pub fn device(&amp;mut self) -&gt; &amp;mut File {
        &amp;mut self.device
    }
}</code></pre>
<p>and import it inside <code>netstack/virtual-interface/src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">pub mod tap;</code></pre>
<p>To test the code let’s start with an example <code>netstack/virtual-interface/examples/read_loop.rs</code></p>
<pre><code class="language-rust ignore">use std::io::Read;
use virtual_interface::tap::VirtualInterface;

fn main() {
    let mut interface = VirtualInterface::create("dev0").unwrap();
    let mut buffer = [0; 4096];
    println!("starting read loop for device `dev0`");
    loop {
        let n = interface.device().read(&amp;mut buffer[..]).unwrap();
        println!("The bytes: {:?}", &amp;buffer[..n]);
    }
}</code></pre>
<p>and build and run it:</p>
<pre><code class="language-bash ignore">$ cargo build --example read_loop
$ ./target/debug/examples/read_loop
</code></pre>
<p>Oh, no some ioctl error: <code>thread 'main' panicked at 'called Result::unwrap() on an Err value: IoctlError'</code>. Let’s debug with strace.</p>
<pre><code class="language-bash ignore">$ strace ./target/debug/examples/read_loop
...
ioctl(3, TUNSETIFF, 0xffffce5f30e0)     = -1 EPERM (Operation not permitted)
...
</code></pre>
<p>So it complains about permissions. Yes, checking <code>man 7 netdevice</code> again</p>
<blockquote>
<p>If an ioctl is marked as privileged, then using it requires an effective user ID of 0  or  the CAP_NET_ADMIN capability.  If this is not the case, EPERM will be returned.</p>
</blockquote>
<p>So let’s try with <code>sudo ./target/debug/examples/read_loop</code> and check if the inerface is created in another terminal:</p>
<pre><code class="language-bash ignore">$ ip link show dev0
dev0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether b2:24:f3:9a:71:c1 brd ff:ff:ff:ff:ff:ff
</code></pre>
<p>It works!<sup class="footnote-reference"><a href="#ip_cli">3</a></sup> But how our binary knows how to call <code>libc</code> functions and use <code>libc</code> structs? Rust dynamically links some system libraries and <code>libc</code> is among them:</p>
<pre><code class="language-bash ignore">$ ldd ./target/debug/examples/read_loop
linux-vdso.so.1 (0x0000ffffb2199000)
libgcc_s.so.1 =&gt; /lib/aarch64-linux-gnu/libgcc_s.so.1 (0x0000ffffb20c0000)
libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffffb1f10000)
/lib/ld-linux-aarch64.so.1 (0x0000ffffb2160000)
</code></pre>
<p>So our <code>netstack/bindings</code> works as expected.</p>
<p>Now you can think that giving <code>sudo</code> access to the program is probably too much power and you’re right. And Linux comes to resque with its capabilities<sup class="footnote-reference"><a href="#capabilities">4</a></sup> system allowing to provide grains of superuser power. So we need to provide only <code>CAP_NET_ADMIN</code> capability to our program. From <code>man capabilities</code>:</p>
<pre><code class="language-ignore">CAP_NET_ADMIN
    Perform various network-related operations:
    * interface configuration;
    * administration of IP firewall, masquerading, and accounting;
    * modify routing tables;
    * bind to any address for transparent proxying;
    * set type-of-service (TOS);
    * clear driver statistics;
    * set promiscuous mode;
    * enabling multicasting;
</code></pre>
<p>Note: if a filesystem with your compiled binary is mounted with <code>nosuid</code> flag (for example, a home directory is encrypted - you can check the flag for a home directory with the command <code>mount | grep $USER</code>) then you should copy the binary to some other directory which filesystem has not <code>nosuid</code> flag.</p>
<pre><code class="language-bash ignore">$ sudo setcap cap_net_admin=eip target/debug/examples/read_loop
</code></pre>
<p>Now let’s run our example binary. In another terminal run <code>ip link show dev0</code> and check that the interface is down, so let’s make it up with <code>sudo ip link set dev0 up</code>. Now we can see some bytes in the console and our next task is to decode them.</p>
<div class="footnote-definition" id="userspace_tcpip"><sup class="footnote-definition-label">1</sup>
<p>Actually offloading network stack to a userspace in traditional heavy-kernel OSes (as opposed to so called microkernel OSes) can bring performance boost - see for example <a href="https://github.com/Xilinx-CNS/onload">OpenOnload</a>.</p>
</div>
<div class="footnote-definition" id="tcpip_tutorial"><sup class="footnote-definition-label">2</sup>
<p>Many of the practice in this chapter is inspired by an excellent <a href="http://www.saminiir.com/lets-code-tcp-ip-stack-1-ethernet-arp/">Let’s code a TCP/IP stack, 1: Ethernet &amp; ARP</a> tutorial by <a href="https://github.com/saminiir">Sami Niiranen</a>.</p>
</div>
<div class="footnote-definition" id="capabilities"><sup class="footnote-definition-label">4</sup>
<p>Comprehensive overview of Linux capabilities and different related exploits can be found at <a href="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities">Linux Capabilities</a> by Carlos Polop.</p>
</div>
<div class="footnote-definition" id="ip_cli"><sup class="footnote-definition-label">3</sup>
<p>We could create a TAP device with the command <code>sudo ip tuntap add dev0 mode tap</code>. The only difference with our programmatically created device is that our device is not persistent - it lives while our process lives. To make our device persistent we could just add the flag <code>IFF_PERSIST</code> to <code>ifru_flags</code>.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../introduction/network.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../introduction/network-properties.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../introduction/network.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../introduction/network-properties.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
